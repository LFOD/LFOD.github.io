---
title: "Are two wrong models better than one? Missing data style"
author: Lucy D'Agostino McGowan
date: '2023-04-29'
categories: ["rstats", "simulations", "missing data"]
description: "Would imputing + fitting an outcome model using the wrong variables be better than just fitting the wrong outcome model? Let's investigate!"
---

After my [previous post about missing data](https://livefreeordichotomize.com/posts/2023-04-28-imputation-might-be-silly/), Kathy [asked on Twitter](https://twitter.com/CausalKathy/status/1652138888100470785?s=20) whether two wrong models (the imputation model + the outcome model) would be better than one (the outcome model alone).

> Without doing any of the math, I'd guess the assumption of correctly spec the model also has a bigger impact in the CC analysis.

> You need correct spec in MI, twice, but trade off that potential bias for higher prec.

This is a great question! I am going to investigate via a small simulation (so the answer could be "it depends", but at least we will know how it seems to work in this very simple case) `r emo::ji("laughing")`.

Ok so here I have some predictor, `x` that is missing 50% of the time, dependent on `c_x` and `c_y`. The right imputation model would have `c_x`, the right outcome model needs `c_y`. Unfortunately, we only have access to one, which we will try to use in our imputation model (and outcome model). Let's see whether two (wrong) models are better than one!

A "correct" model will be one that estimates that the coefficient for `x` is 1. 

```{r}
#| message: false
#| warning: false
library(tidyverse)
library(broom)
library(mice)

n <- 1000

set.seed(928)

data <- tibble(
  c_x = rnorm(n, sd = 0.71),
  x = c_x + rnorm(n, sd = 0.71),
  c_y = rnorm(n),
  y = x + c_y + rnorm(n),
  noise = rnorm(n),
  x_miss = rbinom(n, 1, 1 / (1 + exp(-(c_x + c_y)))),
  x_obs = ifelse(
    x_miss,
    NA,
    x
  )
)

```

## We only have `c_x`

Ok first let's look at the whole dataset.

```{r}
mod_full_c_x <- lm(y ~ x + c_x, data = data) |>
  tidy(conf.int = TRUE) |>
  filter(term == "x") |>
  select(estimate, conf.low, conf.high)

mod_full_c_x
```

This checks out! `c_x` basically does nothing for us here, but because `c_y` is not actually a confounder (it just informs the missingness & `y`, which we aren't observing here), we are just fine estimating our "wrong" model in the fully observed data. Now let's do the "complete cases" analysis.

```{r}
data_cc <- na.omit(data)
mod_cc_c_x <- lm(y ~ x + c_x, data = data_cc) |>
  tidy(conf.int = TRUE) |>
  filter(term == "x") |>
  select(estimate, conf.low, conf.high)

mod_cc_c_x
```
This does fine! Now let's do some imputation. I am going to use the `mice` package.

```{r}
imp_data_c_x <- mice(
  data, 
  m = 5, 
  method = "norm.predict",
  formulas = list(x_obs ~ c_x),
  print = FALSE)
```

Ok let's compare how this model does "alone".

```{r}
mod_imp_c_x <- with(imp_data_c_x, lm(y ~ x_obs)) |>
  pool() |>
  tidy(conf.int = TRUE) |>
  filter(term == "x_obs") |>
  select(estimate, conf.low, conf.high)

mod_imp_c_x
```

Great! This was the right model, so we would expect this to perform well.

Now what happens if we adjust for `c_x` in addition in the outcome model:

```{r}
mod_double_c_x <- with(imp_data_c_x, lm(y ~ x_obs + c_x)) |>
  pool() |>
  tidy(conf.int = TRUE) |>
  filter(term == "x_obs") |>
  select(estimate, conf.low, conf.high)

mod_double_c_x
```
The right imputation model with the wrong outcome model is fine!

## We only have `c_y`

Ok first let's look at the whole dataset.

```{r}
mod_full_c_y <- lm(y ~ x + c_y, data = data) |>
  tidy(conf.int = TRUE) |>
  filter(term == "x") |>
  select(estimate, conf.low, conf.high)

mod_full_c_y
```

Looks good! Now let's do the "complete cases" analysis.

```{r}
mod_cc_c_y <- lm(y ~ x + c_y, data = data_cc) |>
  tidy(conf.int = TRUE) |>
  filter(term == "x") |>
  select(estimate, conf.low, conf.high)

mod_cc_c_y
```

Great! It works. This shows that as long as we have the right outcome model we can do complete case analysis even if the data is missing not at random (cool!). Now let's do some imputation. 

```{r}
imp_data_c_y <- mice(
  data, 
  m = 5, 
  method = "norm.predict",
  formulas = list(x_obs ~ c_y),
  print = FALSE)
```

Ok let's compare how this model does "alone".

```{r}
mod_imp_c_y <- with(imp_data_c_y,lm(y ~ x_obs)) |>
  pool() |>
  tidy(conf.int = TRUE) |>
  filter(term == "x_obs") |>
  select(estimate, conf.low, conf.high)

mod_imp_c_y
```

Oh no, very bad! The wrong imputation model is worse than complete case! By a lot! This estimate is off by 0.31. Does conditioning on `c_y` help us at all?

```{r}
mod_double_c_y <-  with(imp_data_c_y, lm(y ~ x_obs + c_y)) |>
  pool() |>
  tidy(conf.int = TRUE) |>
  filter(term == "x_obs") |>
  select(estimate, conf.low, conf.high)

mod_double_c_y
```

Phew, the wrong imputation model with the wrong outcome model is back to being fine.

## What if both are wrong?

Ok, what if we just had our useless variable, `noise`. 

```{r}
mod_full_noise <- lm(y ~ x + noise, data = data) |>
  tidy(conf.int = TRUE) |>
  filter(term == "x") |>
  select(estimate, conf.low, conf.high)

mod_full_noise
```
This is fine! `c_x` and `c_y` aren't confoudners so we can estimate the coefficent for `x` without them -- `noise` doesn't do anything, but it also doesn't hurt. What about complete case?

```{r}
mod_cc_noise <- lm(y ~ x + noise, data = data_cc) |>
  tidy(conf.int = TRUE) |>
  filter(term == "x") |>
  select(estimate, conf.low, conf.high)

mod_cc_noise
```

Oops! We've got bias (as expected!) -- we end up with a biased estimate by ~0.11.

What if we build the (wrong) imputation model?

```{r}
imp_data_noise <- mice(
  data, 
  m = 5, 
  method = "norm.predict",
  formulas = list(x_obs ~ noise),
  print = FALSE) 
```

Ok let's compare how this model does "alone".

```{r}
mod_imp_noise <-  with(imp_data_noise, lm(y ~ x_obs)) |>
  pool() |>
  tidy(conf.int = TRUE) |>
  filter(term == "x_obs") |>
  select(estimate, conf.low, conf.high)

mod_imp_noise
```

This is also wrong (womp womp!) What if we try two wrong models?

```{r}
mod_double_noise <-  with(imp_data_noise,lm(y ~ x_obs + noise)) |>
  pool() |>
  tidy(conf.int = TRUE) |>
  filter(term == "x_obs") |>
  select(estimate, conf.low, conf.high)

mod_double_noise
```

Nope `r emo::ji("cry")`. Two wrong models here are not better than one! It's worse! Womp womp. 

Let's put these all together:

```{r}
bind_rows(
  mod_full_c_x,
  mod_full_c_y,
  mod_full_noise,
  mod_cc_c_x,
  mod_cc_c_y,
  mod_cc_noise,
  mod_imp_c_x,
  mod_imp_c_y,
  mod_imp_noise,
  mod_double_c_x,
  mod_double_c_y,
  mod_double_noise
) |>
  mutate(
    mod = factor(c("Full data with c_x", 
                   "Full data with c_y", 
                   "Full data with noise",
                   "Complete case with c_x",
                   "Complete case wtih c_y",
                   "Complete case with noise",
                   "Imputation with c_x",
                   "Imputation with c_y",
                   "Imputation with noise",
                   "Two models with c_x",
                   "Two models with c_y",
                   "Two models with noise" ),
                 levels = c("Full data with c_x", 
                            "Complete case with c_x",
                            "Imputation with c_x",
                            "Two models with c_x",
                            "Full data with c_y", 
                            "Complete case wtih c_y",
                            "Imputation with c_y",
                            "Two models with c_y",
                            "Full data with noise",
                            "Complete case with noise",
                            "Imputation with noise",
                            "Two models with noise" )),
    mod = fct_rev(mod),
  ) -> to_plot

ggplot(to_plot, aes(x = estimate, xmin = conf.low, xmax = conf.high, y = mod)) +
  geom_pointrange() + 
  geom_vline(xintercept = 1, lty = 2)
```

So there you have it, two wrong models are rarely better than one.

## Addendum!

In writing this post, I found that I was getting biased results when I was correctly specifying my imputation model when using the `{mice}` defaults (which is why the code above specifies `norm.predict` for the method, forcing it to use linear regression, as the data were generated). I don't understand why this is happening (and am completely open to it being some kind of user error on my part!). But here are those results in case someone can help me figure it out.

```{r}
imp_default_c_x <- mice(
  data, 
  m = 5, 
  formulas = list(x_obs ~ c_x),
  print = FALSE)
```

```{r}
mod_imp_c_x <- with(imp_default_c_x, lm(y ~ x_obs)) |>
  pool() |>
  tidy(conf.int = TRUE) |>
  filter(term == "x_obs") |>
  select(estimate, conf.low, conf.high)

mod_imp_c_x
```

Bad!

```{r}
mod_double_c_x <-  with(imp_default_c_x, lm(y ~ x_obs + c_x)) |>
  pool() |>
  tidy(conf.int = TRUE) |>
  filter(term == "x_obs") |>
  select(estimate, conf.low, conf.high)

mod_double_c_x
```

Even worse!!

```{r}
imp_default_c_y <- mice(
  data, 
  m = 5, 
  formulas = list(x_obs ~ c_y),
  print = FALSE)
```

```{r}
mod_imp_c_y <- with(imp_default_c_y, lm(y ~ x_obs)) |>
  pool() |>
  tidy(conf.int = TRUE) |>
  filter(term == "x_obs") |>
  select(estimate, conf.low, conf.high)

mod_imp_c_y
```

YIKES!

```{r}
mod_double_c_y <-  with(imp_default_c_y, lm(y ~ x_obs + c_y)) |>
  pool() |>
  tidy(conf.int = TRUE) |>
  filter(term == "x_obs") |>
  select(estimate, conf.low, conf.high)

mod_double_c_y
```

Better since we are conditioning on `c_y` (but still bad!)

```{r}
imp_default_noise <- mice(
  data, 
  m = 5, 
  formulas = list(x_obs ~ noise),
  print = FALSE) 
```

```{r}
mod_imp_noise <-  with(imp_default_noise, lm(y ~ x_obs)) |>
  pool() |>
  tidy(conf.int = TRUE) |>
  filter(term == "x_obs") |>
  select(estimate, conf.low, conf.high)

mod_imp_noise
```

EEK!

```{r}
mod_double_noise <-  with(imp_default_noise,lm(y ~ x_obs + noise)) |>
  pool() |>
  tidy(conf.int = TRUE) |>
  filter(term == "x_obs") |>
  select(estimate, conf.low, conf.high)

mod_double_noise
```

Just as bad..

Let's put those in the original plot:

```{r}
bind_rows(
  mod_full_c_x,
  mod_full_c_y,
  mod_full_noise,
  mod_cc_c_x,
  mod_cc_c_y,
  mod_cc_noise,
  mod_imp_c_x,
  mod_imp_c_y,
  mod_imp_noise,
  mod_double_c_x,
  mod_double_c_y,
  mod_double_noise
) |>
  mutate(
    mod = factor(c("Full data with c_x", 
                   "Full data with c_y", 
                   "Full data with noise",
                   "Complete case with c_x",
                   "Complete case wtih c_y",
                   "Complete case with noise",
                   "Default Imputation with c_x",
                   "Default Imputation with c_y",
                   "Default Imputation with noise",
                   "Two models with c_x",
                   "Two models with c_y",
                   "Two models with noise" ),
                 levels = c("Full data with c_x", 
                            "Complete case with c_x",
                            "Default Imputation with c_x",
                            "Two models with c_x",
                            "Full data with c_y", 
                            "Complete case wtih c_y",
                            "Default Imputation with c_y",
                            "Two models with c_y",
                            "Full data with noise",
                            "Complete case with noise",
                            "Default Imputation with noise",
                            "Two models with noise" )),
    mod = fct_rev(mod),
  ) -> to_plot

ggplot(to_plot, aes(x = estimate, xmin = conf.low, xmax = conf.high, y = mod)) +
  geom_pointrange() + 
  geom_vline(xintercept = 1, lty = 2)
```
AHH! This makes me so scared of imputation!!

